/* RealBoy Debugger.
 * Copyright (C) 2025 Sergio GÃ³mez Del Real <sgdr>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "disasm.h"

char *str_instrs[] = {
	"nop",
	"ld bc, (0x%hx)",
	"ld (bc), a",
	"inc bc",
	"inc b",
	"dec b",
	"ld b, (0x%hx)",
	"rlca",
	"ld (0x%hx), sp",
	"add hl, bc",
	"ld a, (bc)",
	"dec bc",
	"inc c",
	"dec c",
	"ld c, (0x%hx)",
	"rrca",

	"stop 0x%hx",
	"ld de, (0x%hx)",
	"ld (de), a",
	"inc de",
	"inc d",
	"dec d",
	"ld d, (0x%hx)",
	"rla",
	"jr %hhd",
	"add hl, de",
	"ld a, (de)",
	"dec de",
	"inc e",
	"dec e",
	"ld e, (0x%hx)",
	"rra",

	"jr nz %hhd",
	"ld hl, (0x%hx)",
	"ld (hl+), a",
	"inc hl",
	"inc h",
	"dec h",
	"ld h, (0x%hx)",
	"daa",
	"jr z %hhd",
	"add hl, hl",
	"ld a, (hl+)",
	"dec hl",
	"inc l",
	"dec l",
	"ld l, (0x%hx)",
	"cpl",

	"jr nc %hhd",
	"ld sp, (0x%hx)",
	"ld (hl-), a",
	"inc sp",
	"inc (hl)",
	"dec (hl)",
	"ld (hl), (0x%hx)",
	"scf",
	"jr c %hhd",
	"add hl, sp",
	"ld a, (hl-)",
	"dec sp",
	"inc a",
	"dec a",
	"ld a, (0x%hx)",
	"ccf",

	"ld b, b",
	"ld b, c",
	"ld b, d",
	"ld b, e",
	"ld b, h",
	"ld b, l",
	"ld b, (hl)",
	"ld b, a",
	"ld c, b",
	"ld c, c",
	"ld c, d",
	"ld c, e",
	"ld c, h",
	"ld c, l",
	"ld c, (hl)",
	"ld c, a",

	"ld d, b",
	"ld d, c",
	"ld d, d",
	"ld d, e",
	"ld d, h",
	"ld d, l",
	"ld d, (hl)",
	"ld d, a",
	"ld e, b",
	"ld e, c",
	"ld e, d",
	"ld e, e",
	"ld e, h",
	"ld e, l",
	"ld e, (hl)",
	"ld e, a",

	"ld h, b",
	"ld h, c",
	"ld h, d",
	"ld h, e",
	"ld h, h",
	"ld h, l",
	"ld h, (hl)",
	"ld h, a",
	"ld l, b",
	"ld l, c",
	"ld l, d",
	"ld l, e",
	"ld l, h",
	"ld l, l",
	"ld l, (hl)",
	"ld l, a",

	"ld (hl), b",
	"ld (hl), c",
	"ld (hl), d",
	"ld (hl), e",
	"ld (hl), h",
	"ld (hl), l",
	"halt",
	"ld (hl), a",
	"ld a, b",
	"ld a, c",
	"ld a, d",
	"ld a, e",
	"ld a, h",
	"ld a, l",
	"ld a, (hl)",
	"ld a, a",

	"add a, b",
	"add a, c",
	"add a, d",
	"add a, e",
	"add a, h",
	"add a, l",
	"add a, (hl)",
	"add a, a",
	"adc a, b",
	"adc a, c",
	"adc a, d",
	"adc a, e",
	"adc a, h",
	"adc a, l",
	"adc a, (hl)",
	"adc a, a",

	"sub a, b",
	"sub a, c",
	"sub a, d",
	"sub a, e",
	"sub a, h",
	"sub a, l",
	"sub a, (hl)",
	"sub a, a",
	"sbc a, b",
	"sbc a, c",
	"sbc a, d",
	"sbc a, e",
	"sbc a, h",
	"sbc a, l",
	"sbc a, (hl)",
	"sbc a, a",

	"and a, b",
	"and a, c",
	"and a, d",
	"and a, e",
	"and a, h",
	"and a, l",
	"and a, (hl)",
	"and a, a",
	"xor a, b",
	"xor a, c",
	"xor a, d",
	"xor a, e",
	"xor a, h",
	"xor a, l",
	"xor a, (hl)",
	"xor a, a",

	"or a, b",
	"or a, c",
	"or a, d",
	"or a, e",
	"or a, h",
	"or a, l",
	"or a, (hl)",
	"or a, a",
	"cp a, b",
	"cp a, c",
	"cp a, d",
	"cp a, e",
	"cp a, h",
	"cp a, l",
	"cp a, (hl)",
	"cp a, a",

	"ret nz",
	"pop bc",
	"jp nz (0x%hx)",
	"jp (0x%hx)",
	"call nz (0x%hx)",
	"push bc",
	"add a, (0x%hx)",
	"rst 0x00",
	"ret z",
	"ret",
	"jp z (0x%hx)",
	"prefix",
	"call z (0x%hx)",
	"call (0x%hx)",
	"adc a, (0x%hx)",
	"rst 0x08",

	"ret nc",
	"pop de",
	"jp nc (0x%hx)",
	"invalid",
	"call nc (0x%hx)",
	"push de",
	"sub a, (0x%hx)",
	"rst 0x10",
	"ret c",
	"reti",
	"jp c (0x%hx)",
	"invalid",
	"call c (0x%hx)",
	"invalid",
	"sbc a, (0x%hx)",
	"rst 0x18",

	"ldh (0x%hx), a",
	"pop hl",
	"ldh (c), a",
	"invalid",
	"invalid",
	"push hl",
	"and a, (0x%hx)",
	"rst 0x20",
	"add sp, (%hhd)",
	"jp hl",
	"ld (0x%hx), a",
	"invalid",
	"invalid",
	"invalid",
	"xor a, (0x%hx)",
	"rst 0x28",

	"ldh a, (0x%hx)",
	"pop af",
	"ldh a, (c)",
	"di",
	"invalid",
	"push af",
	"or a, (0x%hx)",
	"rst 0x30",
	"ld hl, sp+%hhd",
	"ld sp, hl",
	"ld a, (0x%hx)",
	"ei",
	"invalid",
	"invalid",
	"cp a, (0x%hx)",
	"rst 0x38",
};

char *str_instrs_prefix[] = {
	"rlc a, b",
	"rlc a, c",
	"rlc a, d",
	"rlc a, e",
	"rlc a, h",
	"rlc a, l",
	"rlc a, (hl)",
	"rlc a, a",
	"rrc a, b",
	"rrc a, c",
	"rrc a, d",
	"rrc a, e",
	"rrc a, h",
	"rrc a, l",
	"rrc a, (hl)",
	"rrc a, a",

	"rl a, b",
	"rl a, c",
	"rl a, d",
	"rl a, e",
	"rl a, h",
	"rl a, l",
	"rl a, (hl)",
	"rl a, a",
	"rr a, b",
	"rr a, c",
	"rr a, d",
	"rr a, e",
	"rr a, h",
	"rr a, l",
	"rr a, (hl)",
	"rr a, a",

	"sla a, b",
	"sla a, c",
	"sla a, d",
	"sla a, e",
	"sla a, h",
	"sla a, l",
	"sla a, (hl)",
	"sla a, a",
	"sra a, b",
	"sra a, c",
	"sra a, d",
	"sra a, e",
	"sra a, h",
	"sra a, l",
	"sra a, (hl)",
	"sra a, a",

	"swap a, b",
	"swap a, c",
	"swap a, d",
	"swap a, e",
	"swap a, h",
	"swap a, l",
	"swap a, (hl)",
	"swap a, a",
	"srl a, b",
	"srl a, c",
	"srl a, d",
	"srl a, e",
	"srl a, h",
	"srl a, l",
	"srl a, (hl)",
	"srl a, a",

	"bit0 a, b",
	"bit0 a, c",
	"bit0 a, d",
	"bit0 a, e",
	"bit0 a, h",
	"bit0 a, l",
	"bit0 a, (hl)",
	"bit0 a, a",
	"bit1 a, b",
	"bit1 a, c",
	"bit1 a, d",
	"bit1 a, e",
	"bit1 a, h",
	"bit1 a, l",
	"bit1 a, (hl)",
	"bit1 a, a",

	"bit2 a, b",
	"bit2 a, c",
	"bit2 a, d",
	"bit2 a, e",
	"bit2 a, h",
	"bit2 a, l",
	"bit2 a, (hl)",
	"bit2 a, a",
	"bit3 a, b",
	"bit3 a, c",
	"bit3 a, d",
	"bit3 a, e",
	"bit3 a, h",
	"bit3 a, l",
	"bit3 a, (hl)",
	"bit3 a, a",

	"bit4 a, b",
	"bit4 a, c",
	"bit4 a, d",
	"bit4 a, e",
	"bit4 a, h",
	"bit4 a, l",
	"bit4 a, (hl)",
	"bit4 a, a",
	"bit5 a, b",
	"bit5 a, c",
	"bit5 a, d",
	"bit5 a, e",
	"bit5 a, h",
	"bit5 a, l",
	"bit5 a, (hl)",
	"bit5 a, a",

	"bit6 a, b",
	"bit6 a, c",
	"bit6 a, d",
	"bit6 a, e",
	"bit6 a, h",
	"bit6 a, l",
	"bit6 a, (hl)",
	"bit6 a, a",
	"bit7 a, b",
	"bit7 a, c",
	"bit7 a, d",
	"bit7 a, e",
	"bit7 a, h",
	"bit7 a, l",
	"bit7 a, (hl)",
	"bit7 a, a",

	"res0 a, b",
	"res0 a, c",
	"res0 a, d",
	"res0 a, e",
	"res0 a, h",
	"res0 a, l",
	"res0 a, (hl)",
	"res0 a, a",
	"res1 a, b",
	"res1 a, c",
	"res1 a, d",
	"res1 a, e",
	"res1 a, h",
	"res1 a, l",
	"res1 a, (hl)",
	"res1 a, a",

	"res2 a, b",
	"res2 a, c",
	"res2 a, d",
	"res2 a, e",
	"res2 a, h",
	"res2 a, l",
	"res2 a, (hl)",
	"res2 a, a",
	"res3 a, b",
	"res3 a, c",
	"res3 a, d",
	"res3 a, e",
	"res3 a, h",
	"res3 a, l",
	"res3 a, (hl)",
	"res3 a, a",

	"res4 a, b",
	"res4 a, c",
	"res4 a, d",
	"res4 a, e",
	"res4 a, h",
	"res4 a, l",
	"res4 a, (hl)",
	"res4 a, a",
	"res5 a, b",
	"res5 a, c",
	"res5 a, d",
	"res5 a, e",
	"res5 a, h",
	"res5 a, l",
	"res5 a, (hl)",
	"res5 a, a",

	"res6 a, b",
	"res6 a, c",
	"res6 a, d",
	"res6 a, e",
	"res6 a, h",
	"res6 a, l",
	"res6 a, (hl)",
	"res6 a, a",
	"res7 a, b",
	"res7 a, c",
	"res7 a, d",
	"res7 a, e",
	"res7 a, h",
	"res7 a, l",
	"res7 a, (hl)",
	"res7 a, a",

	"set0 a, b",
	"set0 a, c",
	"set0 a, d",
	"set0 a, e",
	"set0 a, h",
	"set0 a, l",
	"set0 a, (hl)",
	"set0 a, a",
	"set1 a, b",
	"set1 a, c",
	"set1 a, d",
	"set1 a, e",
	"set1 a, h",
	"set1 a, l",
	"set1 a, (hl)",
	"set1 a, a",

	"set2 a, b",
	"set2 a, c",
	"set2 a, d",
	"set2 a, e",
	"set2 a, h",
	"set2 a, l",
	"set2 a, (hl)",
	"set2 a, a",
	"set3 a, b",
	"set3 a, c",
	"set3 a, d",
	"set3 a, e",
	"set3 a, h",
	"set3 a, l",
	"set3 a, (hl)",
	"set3 a, a",

	"set4 a, b",
	"set4 a, c",
	"set4 a, d",
	"set4 a, e",
	"set4 a, h",
	"set4 a, l",
	"set4 a, (hl)",
	"set4 a, a",
	"set5 a, b",
	"set5 a, c",
	"set5 a, d",
	"set5 a, e",
	"set5 a, h",
	"set5 a, l",
	"set5 a, (hl)",
	"set5 a, a",

	"set6 a, b",
	"set6 a, c",
	"set6 a, d",
	"set6 a, e",
	"set6 a, h",
	"set6 a, l",
	"set6 a, (hl)",
	"set6 a, a",
	"set7 a, b",
	"set7 a, c",
	"set7 a, d",
	"set7 a, e",
	"set7 a, h",
	"set7 a, l",
	"set7 a, (hl)",
	"set7 a, a",
};

char *disasm(uint32_t *instr, size_t size) {
	char *dis = NULL;
	uint8_t opcode = (uint8_t)instr[0];
	if (size > 4) {
		uint32_t value = size == 12 ? instr[1] | (instr[2] << 8) : instr[1];
		if (size == 12) {
			dis = calloc(1, 8+strlen(str_instrs[opcode])+2+20);
			if (dis) {
				sprintf(dis, str_instrs[opcode], value);
			}
		}
		else {
			dis = calloc(1, 8+strlen(str_instrs[opcode])+20);
			if (dis) {
				sprintf(dis, str_instrs[opcode], (int8_t)value); // value is signed
			}
		}
	}
	else {
		dis = calloc(1, 8+strlen(str_instrs[opcode])+20);
		if (dis) {
			sprintf(dis, str_instrs[opcode]);
		}
	}
	return dis;
}
